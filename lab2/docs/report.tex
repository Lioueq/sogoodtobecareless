\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}

% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,2 по курсу дискрeтного анализа: Сбалансированные деревья
}

Выполнил студент группы 08-215 МАИ \textit{Тараскаев Давид}.

\subsection*{Условие}


Необходимо создать программную библиотеку, реализующую указанную структуру данных, на основе которой разработать программу-словарь. В словаре каждому ключу, представляющему из себя регистронезависимую последовательность букв английского алфавита длиной не более 256 символов, поставлен в соответствие некоторый номер, от 0 до $2^{64}$ - 1. \\
Структура данных: AVL-дерево.


\begin{enumerate}
    \item Представление ключей: при каждом вводе ключ приводится к нижнему регистру функцией \verb|to_lower|.
    \item Узлы дерева: структура \texttt{Node} хранит:
      \begin{itemize}
        \item \texttt{char key[257]} — ключ-строку;
        \item \texttt{uint64\_t value} — связанное значение;
        \item \texttt{int height} — высоту поддерева;
        \item указатели на левого и правого потомка.
      \end{itemize}
    \item Балансировка: при вставке и удалении вычисляется баланс-фактор, при необходимости делаются одно- и двукратные повороты (\texttt{rotateLeft}, \texttt{rotateRight}, \texttt{bigRotateLeft}, \texttt{bigRotateRight}).
    \item Сохранение/загрузка:  
      \texttt{SaveToFile} рекурсивно обходит узлы, записывая маркер присутствия, ключ и значение;  
      \texttt{LoadFromFile} восстанавливает дерево по тем же правилам, проверяя целостность формата.
  \end{enumerate}
  
  \subsection*{Описание программы}
  
  \begin{description}
    \item[{to\_lower(src, dst)}] --- копирует строку \texttt{src} в \texttt{dst}, переводя буквы в нижний регистр.
    \item[\texttt{struct Node}] --- представление узла AVL‑дерева с полями \texttt{key}, \texttt{value}, \texttt{height}, \texttt{left}, \texttt{right}.
    \item[\texttt{class AVL\_Tree}] --- класс-обёртка над корнем дерева, даёт методы:
      \begin{itemize}
        \item \texttt{Insert(key, value)} --- вставка новой пары (или «Exist»);
        \item \texttt{Remove(key)} --- удаление узла по ключу (или «NoSuchWord»);
        \item \texttt{Find(key)} --- поиск значения (или «NoSuchWord»);
        \item \texttt{InorderPrint()} --- вывести все значения в порядке возрастания ключей;
        \item \texttt{SaveToFile(path)}, \texttt{LoadFromFile(path,\dots)}.
        \item \texttt{Повороты и балансировка} реализованы приватными методами \texttt{rotateLeft/Right} и \texttt{bigRotateLeft/Right}.
      \end{itemize}
    \end{description}

\subsection*{Дневник отладки}

Изначально написал код, ни чем себя не ограничивая, потом заменял запрещенные структуры на разрешенные. WA получал из-за неправильного отлавливания ошибок в ходе работы программы.

\subsection*{Тест производительности}

В реализованном AVL дереве 10 миллионов случайных комманд выполняется за 28.52 секунд, а в встроенной в stl map - 28.74.\\Результат нормальный, так как map - это реализация красно-черного дерева и сложность методов поиска, вставки и удаления у обоих деревьев одинаковая - O(log n)

\subsection*{Выводы}

% Описать область применения реализованного алгоритма. Указать типовые
% задачи, решаемые им. Оценить сложность программирования, кратко
% описать возникшие проблемы при решении задачи.
Так как средняя временная сложность алгоритма Бойера-Мура O(N), он исключительно эффективен для задач поиска последовательностей в больших объемах текстовых данных. Это делает его предпочтительным выбором для таких приложений, как функции поиска в текстовых редакторах, анализ исходного кода, поиск специфических последовательностей в биоинформатике, обнаружение известных сигнатур в системах компьютерной безопасности и быстрая фильтрация данных в объемных лог-файлах
\end{document}